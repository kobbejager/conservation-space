package com.sirma.itt.seip;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.BiConsumer;
import java.util.stream.Stream;

/**
 * Properties changes container. Stores all tracked changes and provides means for retrieving them. <br>
 * To add a change one of the methods {@link #add(String, Serializable) add},
 * {@link #update(String, Serializable, Serializable) update} or {@link #remove(String, Serializable) remove}
 * could be used. <br>
 * There are methods for automatic changes recording for collections and maps. To create such instance one of the methods
 * {@link #trackChanges(Map)} or {@link #trackChanges(String, Collection)} could be used
 *
 * @param <S> the type if values stored in the changes
 * @author <a href="mailto:borislav.bonev@sirma.bg">Borislav Bonev</a>
 * @since 30/05/2018
 */
public class PropertiesChanges<S extends Serializable> implements Serializable {

	private LinkedList<PropertyChange<S>> changes = new LinkedList<>();

	/**
	 * Register property change for adding new value to a property
	 *
	 * @param property the property name
	 * @param value the added property value
	 */
	public void add(String property, S value) {
		changes.add(PropertyChange.add(property, value));
	}

	/**
	 * Register property change for updating property value
	 *
	 * @param property the property name
	 * @param newValue the new value to set
	 * @param oldValue the old value that's being overridden
	 */
	public void update(String property, S newValue, S oldValue) {
		if (!Objects.equals(newValue, oldValue)) {
			changes.add(PropertyChange.update(property, newValue, oldValue));
		}
	}

	/**
	 * Register property change for property value removal
	 *
	 * @param property the property name
	 * @param value the removed value
	 */
	public void remove(String property, S value) {
		changes.add(PropertyChange.remove(property, value));
	}

	/**
	 * Stream the recorded changes
	 *
	 * @return changes stream
	 */
	public Stream<PropertyChange<S>> changes() {
		return changes.stream();
	}

	/**
	 * Wrap the given collection into one that can track adding, updating and removing of elements in the collection.<br>
	 * All of the changes will be stored in the current instance
	 *
	 * @param key static key to be assigned to all property changes for the given collection. All changes generated by
	 * modification for the given collection will be written with the key passed when the method is called.
	 * @param delegate the delegate collection to wrap. The concrete supported types are Set and List. Any other
	 * collection sub type will be wrapped in general collection interface
	 * @return a collection that records it's changes in the current instance
	 */
	public <E extends S, C extends List<E>> List<E> trackChanges(String key, C delegate) {
		Objects.requireNonNull(delegate, "Cannot wrap null list");
		if (isTracking(delegate)) {
			return delegate;
		}
		return new TrackedList<>(unTrackChanges(delegate), this, ChangesRecorder.collectionRecorder(key));
	}

	/**
	 * Wrap the given collection into one that can track adding, updating and removing of elements in the collection.<br>
	 * All of the changes will be stored in the current instance
	 *
	 * @param key static key to be assigned to all property changes for the given collection. All changes generated by
	 * modification for the given collection will be written with the key passed when the method is called.
	 * @param delegate the delegate collection to wrap. The concrete supported types are Set and List. Any other
	 * collection sub type will be wrapped in general collection interface
	 * @return a collection that records it's changes in the current instance
	 */
	public <E extends S, C extends Set<E>> Set<E> trackChanges(String key, C delegate) {
		Objects.requireNonNull(delegate, "Cannot wrap null set");
		if (isTracking(delegate)) {
			return delegate;
		}
		return new TrackedSet<>(unTrackChanges(delegate), this, ChangesRecorder.collectionRecorder(key));
	}

	/**
	 * Wrap the given collection into one that can track adding, updating and removing of elements in the collection.<br>
	 * All of the changes will be stored in the current instance
	 *
	 * @param key static key to be assigned to all property changes for the given collection. All changes generated by
	 * modification for the given collection will be written with the key passed when the method is called.
	 * @param delegate the delegate collection to wrap. The concrete supported types are Set and List. Any other
	 * collection sub type will be wrapped in general collection interface
	 * @return a collection that records it's changes in the current instance
	 */
	@SuppressWarnings("unchecked")
	public <E extends S, C extends Collection<E>> Collection<E> trackChanges(String key, C delegate) {
		Objects.requireNonNull(delegate, "Cannot wrap null collection");
		if (isTracking(delegate)) {
			return delegate;
		}
		C originalDelegate = unTrackChanges(delegate);
		ChangesRecorder<E, S> changesRecorder = ChangesRecorder.collectionRecorder(key);
		if (originalDelegate instanceof Set) {
			return new TrackedSet<>((Set<E>) originalDelegate, this, changesRecorder);
		} else if (originalDelegate instanceof List) {
			return new TrackedList<>((List<E>) originalDelegate, this, changesRecorder);
		}
		return new TrackedCollection<>(originalDelegate, this, changesRecorder);
	}

	/**
	 * Unwrap previously wrapped collection by the method {@link #trackChanges(String, Collection)}.
	 *
	 * @param collection the collection to unwrap.
	 * @return the original collection instance passed to the method {@link #trackChanges(String, Collection)} otherwise
	 * 		returns the argument itself
	 */
	@SuppressWarnings("unchecked")
	public static <E extends Serializable, C extends Collection<E>> C unTrackChanges(C collection) {
		if (collection instanceof TrackedCollection) {
			return ((TrackedCollection<E, E, C>) collection).delegate;
		}
		return collection;
	}

	/**
	 * Wrap a given map to track it's changes like addition, removal or value update. The map keys will be used as keys
	 * for the changes identifier. <br>
	 * All of the changes will be stored in the current instance
	 *
	 * @param delegate the map instance to wrap
	 * @return a map that records it's changes in the current instance
	 */
	public Map<String, S> trackChanges(Map<String, S> delegate) {
		Objects.requireNonNull(delegate, "Cannot wrap null map");
		if (isTracking(delegate)) {
			return delegate;
		}
		return new TrackedMap<>(unTrackChanges(delegate), this);
	}

	/**
	 * Unwrap previously wrapped map by the method {@link #trackChanges(Map)}.
	 *
	 * @param <S> value type
	 * @param map the map to unwrap.
	 * @return the original map instance passed to the method {@link #trackChanges(Map)} otherwise
	 * 		returns the argument itself
	 */
	public static <S extends Serializable> Map<String, S> unTrackChanges(Map<String, S> map) {
		if (map instanceof TrackedMap) {
			return ((TrackedMap<S>) map).delegate;
		}
		return map;
	}

	/**
	 * Checks if the given map is tracked and if it's done by the current instance
	 *
	 * @param map is the map to check if it's tracked and if this is done by the current instance
	 * @return true if the given map is tracked by the current instance
	 */
	public boolean isTracking(Map<String, S> map) {
		return map instanceof TrackedMap && ((TrackedMap) map).changes == this;
	}

	/**
	 * Checks if the given collection is tracked and if it's done by the current instance
	 *
	 * @param collection is the collection to check if it's tracked and if this is done by the current instance
	 * @return true if the given collection is tracked by the current instance
	 */
	public <E extends S, C extends Collection<E>> boolean isTracking(C collection) {
		return collection instanceof TrackedCollection && ((TrackedCollection) collection).changes == this;
	}

	/**
	 * Clear any recorded changes until this moment
	 */
	public void clear() {
		changes.clear();
	}

	private static class TrackedMap<V extends Serializable> implements Map<String, V>, Serializable{

		private final Map<String, V> delegate;
		private final PropertiesChanges<V> changes;

		private TrackedMap(Map<String, V> delegate, PropertiesChanges<V> changes) {
			this.delegate = delegate;
			this.changes = changes;
		}

		@Override
		public int size() {
			return delegate.size();
		}

		@Override
		public boolean isEmpty() {
			return delegate.isEmpty();
		}

		@Override
		public boolean containsKey(Object key) {
			return delegate.containsKey(key);
		}

		@Override
		public boolean containsValue(Object value) {
			return delegate.containsValue(value);
		}

		@Override
		public V get(Object key) {
			return delegate.get(key);
		}

		@Override
		public V put(String key, V value) {
			if (value == null) {
				changes.remove(key, delegate.get(key));
			} else {
				V oldValue = delegate.get(key);
				if (oldValue != null) {
					changes.update(key, value, oldValue);
				} else {
					changes.add(key, value);
				}
			}
			return delegate.put(key, value);
		}

		@Override
		public V remove(Object key) {
			V removedValue = delegate.remove(key);
			changes.remove(key.toString(), removedValue);
			return removedValue;
		}

		@Override
		public void putAll(Map<? extends String, ? extends V> m) {
			m.forEach(this::put);
		}

		@Override
		public void clear() {
			// first clone the key set as we are going to modify the map for each element
			new ArrayList<>(delegate.keySet()).forEach(this::remove);
		}

		@Override
		public Set<String> keySet() {
			// the map's key set does not allow additions or updates so we will handle only remove
			return new TrackedSet<>(delegate.keySet(), changes,
					ChangesRecorder.removeOnly((key, propertiesChanges) -> propertiesChanges.remove(key, get(key))));
		}

		@Override
		public Collection<V> values() {
			// for now we will not support map modification via it's values collection
			// current code base does not have a code that depends on this functionality
			return Collections.unmodifiableCollection(delegate.values());
		}

		@Override
		public Set<Entry<String, V>> entrySet() {
			// the map's entry set does not allow additions or updates so we will handle only remove
			return new TrackedSet<>(delegate.entrySet(), changes, ChangesRecorder.removeOnly(
					(entry, propertiesChanges) -> propertiesChanges.remove(entry.getKey(), entry.getValue())));
		}

		@Override
		public boolean equals(Object obj) {
			return obj instanceof Map && delegate.equals(obj);
		}

		@Override
		public int hashCode() {
			return delegate.hashCode();
		}

		@Override
		public String toString() {
			return delegate.toString();
		}
	}

	private static class TrackedCollection<E, C extends Serializable, X extends Collection<E>>
			implements Collection<E>, Serializable {
		protected final X delegate;
		protected final PropertiesChanges<C> changes;
		final ChangesRecorder<E, C> changesRecorder;

		private TrackedCollection(X delegate, PropertiesChanges<C> changes, ChangesRecorder<E, C> changesRecorder) {
			this.delegate = delegate;
			this.changes = changes;
			this.changesRecorder = changesRecorder;
		}

		@Override
		public int size() {
			return delegate.size();
		}

		@Override
		public boolean isEmpty() {
			return delegate.isEmpty();
		}

		@Override
		public boolean contains(Object o) {
			return delegate.contains(o);
		}

		@Override
		public Iterator<E> iterator() {
			return new TrackedIterator<>(delegate.iterator(), changes, changesRecorder);
		}

		@Override
		public Object[] toArray() {
			return delegate.toArray();
		}

		@Override
		public <T> T[] toArray(T[] a) {
			return delegate.toArray(a);
		}

		@Override
		public boolean add(E e) {
			if (delegate.add(e)) {
				changesRecorder.add(e, changes);
				return true;
			}
			return false;
		}

		@Override
		@SuppressWarnings("unchecked")
		public boolean remove(Object o) {
			// need to check if the value is in the collection otherwise the changes recorder cannot fetch dependent
			// value and added it to the changes
			// this is mainly used for map key set as the change happens before recording the old value
			if (delegate.contains((E) o)) {
				changesRecorder.remove((E) o, changes);
				return delegate.remove(o);
			}
			return false;
		}

		@Override
		public boolean containsAll(Collection<?> c) {
			return delegate.containsAll(c);
		}

		@Override
		public boolean addAll(Collection<? extends E> c) {
			boolean changed = false;
			for (E e : c) {
				changed |= add(e);
			}
			return changed;
		}

		@Override
		public boolean removeAll(Collection<?> c) {
			boolean changed = false;
			for (Object o : c) {
				changed |= remove(o);
			}
			return changed;
		}

		@Override
		public boolean retainAll(Collection<?> c) {
			Iterator<E> it = iterator();
			boolean changed = false;
			while (it.hasNext()) {
				if (!c.contains(it.next())) {
					it.remove();
					changed = true;
				}
			}
			return changed;
		}

		@Override
		public void clear() {
			Iterator<E> it = iterator();
			while (it.hasNext()) {
				it.next();
				it.remove();
			}
		}
	}

	private static class ChangesRecorder<E, C extends Serializable> implements Serializable {
		private BiConsumer<E, PropertiesChanges<C>> onAdd;
		private TriConsumer<E, E, PropertiesChanges<C>> onUpdate;
		private BiConsumer<E, PropertiesChanges<C>> onRemove;

		private ChangesRecorder(BiConsumer<E, PropertiesChanges<C>> onAdd,
				TriConsumer<E, E, PropertiesChanges<C>> onUpdate,
				BiConsumer<E, PropertiesChanges<C>> onRemove) {
			this.onAdd = onAdd;
			this.onUpdate = onUpdate;
			this.onRemove = onRemove;
		}

		static <E, C extends Serializable> ChangesRecorder<E, C> removeOnly(
				BiConsumer<E, PropertiesChanges<C>> onRemove) {
			return new ChangesRecorder<>(null, null, onRemove);
		}

		@SuppressWarnings("unchecked")
		static <E extends Serializable, S extends E> ChangesRecorder<S, E> collectionRecorder(String key) {
			return new ChangesRecorder<>((value, c) -> c.add(key, (E) value),
					(newValue, oldValue, c) -> c.update(key, (E) newValue, (E) oldValue), (value, c) -> c.remove(key, (E) value));
		}

		void add(E addedValue, PropertiesChanges<C> changes) {
			onAdd.accept(addedValue, changes);
		}

		void update(E newValue, E oldValue, PropertiesChanges<C> changes) {
			onUpdate.accept(newValue, oldValue, changes);
		}

		void remove(E removedValue, PropertiesChanges<C> changes) {
			onRemove.accept(removedValue, changes);
		}
	}

	private static class TrackedIterator<E, C extends Serializable> implements Iterator<E> {
		private final Iterator<E> delegate;
		private final PropertiesChanges<C> changes;
		private final ChangesRecorder<E, C> changesRecorder;
		private E previousValue;

		private TrackedIterator(Iterator<E> delegate, PropertiesChanges<C> changes,
				ChangesRecorder<E, C> changesRecorder) {
			this.delegate = delegate;
			this.changes = changes;
			this.changesRecorder = changesRecorder;
		}

		@Override
		public boolean hasNext() {
			return delegate.hasNext();
		}

		@Override
		public E next() {
			previousValue = delegate.next();
			return previousValue;
		}

		@Override
		public void remove() {
			delegate.remove();
			changesRecorder.remove(previousValue, changes);
			previousValue = null;
		}
	}

	private static class TrackedSet<E, C extends Serializable> extends TrackedCollection<E, C, Set<E>>
			implements Set<E> {
		private TrackedSet(Set<E> delegate, PropertiesChanges<C> changes, ChangesRecorder<E, C> changesRecorder) {
			super(delegate, changes, changesRecorder);
		}
	}

	private static class TrackedList<E, C extends Serializable> extends TrackedCollection<E, C, List<E>>
			implements List<E> {
		private TrackedList(List<E> delegate, PropertiesChanges<C> changes, ChangesRecorder<E, C> changesRecorder) {
			super(delegate, changes, changesRecorder);
		}

		@Override
		public boolean addAll(int index, Collection<? extends E> c) {
			c.forEach(e -> changesRecorder.add(e, changes));
			return delegate.addAll(index, c);
		}

		@Override
		public E get(int index) {
			return delegate.get(index);
		}

		@Override
		public E set(int index, E element) {
			E previousValue = delegate.set(index, element);
			changesRecorder.update(element, previousValue, changes);
			return previousValue;
		}

		@Override
		public void add(int index, E element) {
			changesRecorder.add(element, changes);
			delegate.add(index, element);
		}

		@Override
		public E remove(int index) {
			E removed = delegate.remove(index);
			changesRecorder.remove(removed, changes);
			return removed;
		}

		@Override
		public int indexOf(Object o) {
			return delegate.indexOf(o);
		}

		@Override
		public int lastIndexOf(Object o) {
			return delegate.lastIndexOf(o);
		}

		@Override
		public ListIterator<E> listIterator() {
			return new TrackedListIterator<>(delegate.listIterator(), changes, changesRecorder);
		}

		@Override
		public ListIterator<E> listIterator(int index) {
			return new TrackedListIterator<>(delegate.listIterator(index), changes, changesRecorder);
		}

		@Override
		public List<E> subList(int fromIndex, int toIndex) {
			return new TrackedList<>(delegate.subList(fromIndex, toIndex), changes, changesRecorder);
		}
	}

	private static class TrackedListIterator<E, C extends Serializable> implements ListIterator<E> {
		private final ListIterator<E> delegate;
		private final PropertiesChanges<C> changes;
		private final ChangesRecorder<E, C> changesRecorder;
		private E lastReturned;

		private TrackedListIterator(ListIterator<E> delegate, PropertiesChanges<C> changes,
				ChangesRecorder<E, C> changesRecorder) {
			this.delegate = delegate;
			this.changes = changes;
			this.changesRecorder = changesRecorder;
		}

		@Override
		public boolean hasNext() {
			return delegate.hasNext();
		}

		@Override
		public E next() {
			lastReturned = delegate.next();
			return lastReturned;
		}

		@Override
		public boolean hasPrevious() {
			return delegate.hasPrevious();
		}

		@Override
		public E previous() {
			lastReturned = delegate.previous();
			return lastReturned;
		}

		@Override
		public int nextIndex() {
			return delegate.nextIndex();
		}

		@Override
		public int previousIndex() {
			return delegate.previousIndex();
		}

		@Override
		public void remove() {
			delegate.remove();
			changesRecorder.remove(lastReturned, changes);
		}

		@Override
		public void set(E e) {
			delegate.set(e);
			changesRecorder.update(e, lastReturned, changes);
			lastReturned = e;
		}

		@Override
		public void add(E e) {
			delegate.add(e);
			changesRecorder.add(e, changes);
		}
	}
}
